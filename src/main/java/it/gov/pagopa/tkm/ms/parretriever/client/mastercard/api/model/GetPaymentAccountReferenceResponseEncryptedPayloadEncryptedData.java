/*
 * Payment Account Reference Inquiry API
 * Merchants, Acquirers, or Digital Activity Customers (DACs) can use this service to query the PAR Vault to obtain a Payment Account Reference(PAR), from a Primary Account Number (PAN). PAR provides an industry-aligned approach designed to help link PAN-based transactions to transactions using associated payment tokens, without using the PAN as the linkage mechanism.
 *
 * The version of the OpenAPI document: 1.3
 * Contact: apisupport@mastercard.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package it.gov.pagopa.tkm.ms.parretriever.client.mastercard.api.model;

import java.util.Objects;

import com.google.gson.annotations.SerializedName;
import io.swagger.annotations.ApiModelProperty;

/**
 * GetPaymentAccountReferenceResponseEncryptedPayloadEncryptedData
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2021-04-15T11:20:33.252+02:00[Europe/Berlin]")
public class GetPaymentAccountReferenceResponseEncryptedPayloadEncryptedData {
  public static final String SERIALIZED_NAME_PAYMENT_ACCOUNT_REFERENCE = "paymentAccountReference";
  @SerializedName(SERIALIZED_NAME_PAYMENT_ACCOUNT_REFERENCE)
  private String paymentAccountReference;

  public static final String SERIALIZED_NAME_DATA_VALID_UNTIL_TIMESTAMP = "dataValidUntilTimestamp";
  @SerializedName(SERIALIZED_NAME_DATA_VALID_UNTIL_TIMESTAMP)
  private String dataValidUntilTimestamp;


  public GetPaymentAccountReferenceResponseEncryptedPayloadEncryptedData paymentAccountReference(String paymentAccountReference) {
    
    this.paymentAccountReference = paymentAccountReference;
    return this;
  }

   /**
   * The PAR assigned to the PAN.&lt;/br&gt; 
   * @return paymentAccountReference
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "50019P9LBXOLHN9G7QMU5VN520YSY", value = "The PAR assigned to the PAN.</br> ")

  public String getPaymentAccountReference() {
    return paymentAccountReference;
  }


  public void setPaymentAccountReference(String paymentAccountReference) {
    this.paymentAccountReference = paymentAccountReference;
  }


  public GetPaymentAccountReferenceResponseEncryptedPayloadEncryptedData dataValidUntilTimestamp(String dataValidUntilTimestamp) {
    
    this.dataValidUntilTimestamp = dataValidUntilTimestamp;
    return this;
  }

   /**
   * The date/time after which this encrypted payload object is considered invalid. If present, all systems must reject this encrypted object after this time and treat it as invalid data. Must be expressed in ISO 8601 extended format as one of the following - YYYY-MM-DDThh:mm:ss[ .sss ]Z, YYYY-MM-DDThh:mm:ss[ .sss ]±hh:mm . Where [ .sss ] is optional and can be 1 to 3 digits. Must be a value no more than 30 days in the future. Mastercard recommends using a value of (Current Time + 30 minutes).
   * @return dataValidUntilTimestamp
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2021-07-04T12:09:56.123-07:00", value = "The date/time after which this encrypted payload object is considered invalid. If present, all systems must reject this encrypted object after this time and treat it as invalid data. Must be expressed in ISO 8601 extended format as one of the following - YYYY-MM-DDThh:mm:ss[ .sss ]Z, YYYY-MM-DDThh:mm:ss[ .sss ]±hh:mm . Where [ .sss ] is optional and can be 1 to 3 digits. Must be a value no more than 30 days in the future. Mastercard recommends using a value of (Current Time + 30 minutes).")

  public String getDataValidUntilTimestamp() {
    return dataValidUntilTimestamp;
  }


  public void setDataValidUntilTimestamp(String dataValidUntilTimestamp) {
    this.dataValidUntilTimestamp = dataValidUntilTimestamp;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GetPaymentAccountReferenceResponseEncryptedPayloadEncryptedData getPaymentAccountReferenceResponseEncryptedPayloadEncryptedData = (GetPaymentAccountReferenceResponseEncryptedPayloadEncryptedData) o;
    return Objects.equals(this.paymentAccountReference, getPaymentAccountReferenceResponseEncryptedPayloadEncryptedData.paymentAccountReference) &&
        Objects.equals(this.dataValidUntilTimestamp, getPaymentAccountReferenceResponseEncryptedPayloadEncryptedData.dataValidUntilTimestamp);
  }

  @Override
  public int hashCode() {
    return Objects.hash(paymentAccountReference, dataValidUntilTimestamp);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GetPaymentAccountReferenceResponseEncryptedPayloadEncryptedData {\n");
    sb.append("    paymentAccountReference: ").append(toIndentedString(paymentAccountReference)).append("\n");
    sb.append("    dataValidUntilTimestamp: ").append(toIndentedString(dataValidUntilTimestamp)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

